In “Basics of the Unix Philosophy,” we read some design principles of the Unix operating system that apply almost verbatim to the problem space of database modeling:

    Rule of modularity: Write simple parts connected by clean interfaces

    Rule of clarity: Clarity is better than cleverness

    Rule of composition: Design programs to be connected to other programs

    Rule of separation: Separate policy from mechanism; separate interfaces from engines

    Rule of simplicity: Design for simplicity; add complexity only where we must

    Rule of parsimony: Write a big program only when it is clear by demonstration that nothing else will do

    Rule of transparency: Design for visibility to make inspection and debugging easier

    Rule of robustness: Robustness is the child of transparency and simplicity

    Rule of representation: Fold knowledge into data so program logic can be stupid and robust

    Rule of least surprise: In interface design, always do the least surprising thing

    Rule of silence: When a program has nothing surprising, it should say nothing

    Rule of repair: When we must fail, fail noisily and as soon as possible

    Rule of economy: Programmer time is expensive; conserve it in preference to machine time

    Rule of generation: Avoid hand-hacking; write programs when we can

    Rule of optimization: Prototype before polishing. Get it working before we optimize it

    Rule of diversity: Distrust all claims for “one true way”

    Rule of extensibility: Design for the future because it will be here sooner than we think
